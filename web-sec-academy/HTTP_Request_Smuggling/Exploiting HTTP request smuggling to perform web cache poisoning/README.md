## Exploiting HTTP request smuggling to perform web cache poisoning

1. Được biết FE server ở đây không xử lý chunked encoding -> CL.TE smuggling.

2. Trong chức năng next post trả về một redirect response và nhận thấy `Host` header không có cơ chế xác thực origin. Khi thay giá trị trường này bằng host bất kỳ thì nó sẽ redirect đến host đó. 

3. Craft một smuggling request 

![image](https://user-images.githubusercontent.com/80744099/227866269-9aa4d44b-ac26-42ce-bcc8-cd96b4d25079.png)

4. Khi gửi smuggling request này lần 1 sẽ pass FE server dễ dàng và nhận được response bình thường. Tuy nhiên khi requets được chuyển đến BE server sau khi đọc xong giá trị 0, BE hiểu là phần body của request đã hết và phần còn lại của request sẽ được cắt và gắn vào request sau.

5. Craft trang exploit server:

![image](https://user-images.githubusercontent.com/80744099/227877718-b4469fab-8d79-47a8-9eaf-affc81d9ecd0.png)

6. Trong các request trong HTTP history, nhận thấy request `GET /resources/js/tracking.js` sử dụng web cache để lưu response.

![image](https://user-images.githubusercontent.com/80744099/227875755-5ea0e653-3563-4690-8662-7ef179119913.png)

7. Như vậy ta có thể khai thác http smuggling request kết hợp webcache bằng cách: sau khi gửi 1 lần smuggling request thì gửi request `GET /resources/js/tracking.js` do phần còn lại trong smuggling request sẽ làm request `GET /resources/js/tracking.js` có dạng:

```
GET /post/next?postId=9 HTTP/1.1
Host: exploit-0a7d00880426fc6ec06a6c8d015100e0.exploit-server.net/
Content-Length: 10

x=yGET /re
```
![image](https://user-images.githubusercontent.com/80744099/227878737-687daf28-7562-432c-a81c-ec795c20f64c.png)

8. Và nó sẽ được lưu trong cache trong vòng 30s. Cứ khi nào có một người dùng access vào request `GET /resources/js/tracking.js` thì nó sẽ redirect đến trang exploit và hiện alert.
